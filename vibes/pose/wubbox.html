<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pose Animator v5.0 (3D)</title>
    <style>
        :root { --accent: #4ade80; --bg: #000; --panel: #1a1a1a; --text: #eee; }
        html, body {
            margin: 0; padding: 0;
            background: var(--bg); color: var(--text);
            font-family: system-ui, -apple-system, sans-serif;
            width: 100%; height: 100%;
            overflow: hidden;
        }
        .screen {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        #setup-screen { background: var(--panel); z-index: 30; padding: 20px; }
        .input-group { width: 100%; max-width: 400px; margin-bottom: 15px; }
        button {
            padding: 15px; background: var(--accent); color: #000;
            border: none; border-radius: 8px; font-weight: bold;
            width: 100%; max-width: 400px; font-size: 1rem; cursor: pointer;
        }
        #live-screen { z-index: 10; }
        #live-controls { position: absolute; top: 15px; left: 15px; z-index: 50; }
        .btn-sm {
            padding: 8px 12px; font-size: 0.8rem; background: rgba(0,0,0,0.5);
            color: white; border: none; border-radius: 4px;
        }
        video {
            display: none; /* Hidden, we just need its data */
        }
        #canvas-container {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
        }
        #output_canvas_3d, #output_canvas_2d {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            transform: rotateY(180deg); /* Mirror view */
        }
        #output_canvas_3d { z-index: 1; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="live-screen" class="screen">
        <div id="live-controls">
            <button class="btn-sm" onclick="location.reload()">Restart</button>
            <button class="btn-sm" id="toggle-skel">Show Skeleton</button>
        </div>
        <video id="webcam" autoplay playsinline></video>
        <div id="canvas-container">
            <canvas id="output_canvas_2d"></canvas>
            <canvas id="output_canvas_3d"></canvas>
        </div>
    </div>

    <script type="module">
        import * as THREE from "https://cdn.skypack.dev/three@0.132.2";
        import { PoseLandmarker, FilesetResolver } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

        let poseLandmarker;
        let scene, camera, renderer;
        let character;
        let showSkeleton = false;
        
        const video = document.getElementById('webcam');
        const canvas2D = document.getElementById('output_canvas_2d');
        const ctx2D = canvas2D.getContext('2d');
        
        let viewWidth, viewHeight, visibleWidth, visibleHeight;

        // --- CORE LOGIC ---
        async function initialize() {
            const vis = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            poseLandmarker = await PoseLandmarker.createFromOptions(vis, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numPoses: 1,
                outputSegmentationMasks: false
            });

            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener('loadeddata', predict);
            });
        }

        function setupThreeJS() {
            const container = document.getElementById('canvas-container');
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('output_canvas_3d'),
                alpha: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            
            const light = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(light);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);

            handleResize();
        }
        
        // --- CHARACTER CREATION ---
        function applySkin(character, texture) {
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;

            const createMaterial = (uvs) => {
                const materials = [];
                for (const uv of uvs) {
                     const canvas = document.createElement('canvas');
                     const context = canvas.getContext('2d');
                     canvas.width = uv.w;
                     canvas.height = uv.h;
                     context.drawImage(texture.image, uv.x, uv.y, uv.w, uv.h, 0, 0, uv.w, uv.h);
                     const newTexture = new THREE.CanvasTexture(canvas);
                     newTexture.magFilter = THREE.NearestFilter;
                     newTexture.minFilter = THREE.NearestFilter;
                     materials.push(new THREE.MeshBasicMaterial({ map: newTexture, transparent: true }));
                }
                return materials;
            };

            // UV mapping for a standard 64x64 Minecraft skin
            // Order: Right, Left, Top, Bottom, Front, Back
            const headUVs = [
                { x: 0, y: 8, w: 8, h: 8 }, { x: 16, y: 8, w: 8, h: 8 },
                { x: 8, y: 0, w: 8, h: 8 }, { x: 16, y: 0, w: 8, h: 8 },
                { x: 8, y: 8, w: 8, h: 8 }, { x: 24, y: 8, w: 8, h: 8 }
            ];
            const torsoUVs = [
                 { x: 16, y: 20, w: 4, h: 12 }, { x: 28, y: 20, w: 4, h: 12 },
                 { x: 20, y: 16, w: 8, h: 4 }, { x: 28, y: 16, w: 8, h: 4 },
                 { x: 20, y: 20, w: 8, h: 12 }, { x: 32, y: 20, w: 8, h: 12 }
            ];
            const armUVs = [
                 { x: 40, y: 20, w: 4, h: 12 }, { x: 48, y: 20, w: 4, h: 12 },
                 { x: 44, y: 16, w: 4, h: 4 }, { x: 48, y: 16, w: 4, h: 4 },
                 { x: 44, y: 20, w: 4, h: 12 }, { x: 52, y: 20, w: 4, h: 12 }
            ];
            const legUVs = [
                 { x: 0, y: 20, w: 4, h: 12 }, { x: 8, y: 20, w: 4, h: 12 },
                 { x: 4, y: 16, w: 4, h: 4 }, { x: 8, y: 16, w: 4, h: 4 },
                 { x: 4, y: 20, w: 4, h: 12 }, { x: 12, y: 20, w: 4, h: 12 }
            ];

            character.head.material = createMaterial(headUVs);
            character.torso.material = createMaterial(torsoUVs);
            character.leftArm.material = createMaterial(armUVs);
            character.rightArm.material = createMaterial(armUVs);
            character.leftLeg.material = createMaterial(legUVs);
            character.rightLeg.material = createMaterial(legUVs);
        }

        function createCharacter(skinTexture) {
            const group = new THREE.Group();
            
            // Define geometry with adjusted pivot points for proper rotation
            const createPart = (w, h, d, pivotY) => {
                const geom = new THREE.BoxGeometry(w, h, d);
                geom.translate(0, -h / 2 + pivotY, 0);
                return new THREE.Mesh(geom);
            };

            const head = createPart(8, 8, 8, 8);
            const torso = createPart(8, 12, 4, 12);
            const leftArm = createPart(4, 12, 4, 12);
            const rightArm = createPart(4, 12, 4, 12);
            const leftLeg = createPart(4, 12, 4, 12);
            const rightLeg = createPart(4, 12, 4, 12);
            
            // Assemble the character
            const body = new THREE.Group();
            body.add(torso);
            body.add(head);
            head.position.y = 12; // Top of torso
            
            const characterContainer = new THREE.Group();
            characterContainer.add(body);
            characterContainer.add(leftArm);
            characterContainer.add(rightArm);
            characterContainer.add(leftLeg);
            characterContainer.add(rightLeg);

            // Set initial positions
            leftArm.position.set(-6, 12, 0);
            rightArm.position.set(6, 12, 0);
            leftLeg.position.set(-2, 0, 0);
            rightLeg.position.set(2, 0, 0);
            
            const parts = { head, torso, leftArm, rightArm, leftLeg, rightLeg, group: characterContainer };
            applySkin(parts, skinTexture);

            return parts;
        }

        // --- POSE & ANIMATION ---
        function updatePose(landmarks) {
            if (!character || !visibleHeight) return;
            const lerpFactor = 0.5;

            // --- 1. SCALE ---
            // Calculate vertical size of the pose in normalized coordinates
            const poseTop = landmarks[0].y; // Nose
            const poseBottom = (landmarks[27].y + landmarks[28].y) / 2; // Midpoint of ankles
            const poseHeightNorm = Math.abs(poseBottom - poseTop);

            // Total height of the 3D model is 32 units (leg 12 + torso 12 + head 8)
            const modelHeight = 32;
            const desiredHeight = poseHeightNorm * visibleHeight;
            const scale = desiredHeight / modelHeight;
            character.group.scale.lerp(new THREE.Vector3(scale, scale, scale), lerpFactor);

            // --- 2. POSITION ---
            // Find the center of the body in normalized coordinates
            const shoulderMidY = (landmarks[11].y + landmarks[12].y) / 2;
            const hipMidX = (landmarks[23].x + landmarks[24].x) / 2;
            const hipMidY = (landmarks[23].y + landmarks[24].y) / 2;
            const bodyCenterY = (shoulderMidY + hipMidY) / 2;

            // Convert normalized coordinates to world coordinates
            // Negate X because the view is mirrored
            const targetX = -(hipMidX - 0.5) * visibleWidth;
            const targetY = -(bodyCenterY - 0.5) * visibleHeight;
            
            // We position the group, which contains all parts
            character.group.position.lerp(new THREE.Vector3(targetX, targetY, 0), lerpFactor);
            
            // --- 3. ROTATION ---
            const getQuaternion = (p1, p2) => {
                const dir = new THREE.Vector3().subVectors(p2, p1).normalize();
                return new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
            };

            const worldLandmarks = landmarks.map(lm => new THREE.Vector3(lm.x, lm.y, lm.z).sub(landmarks[0]).multiplyScalar(-100));
            
            // --- New Head Logic ---
            const pRightEar = worldLandmarks[8];
            const pLeftEar = worldLandmarks[7];
            const pRightShoulder = worldLandmarks[12];
            const pLeftShoulder = worldLandmarks[11];

            const shoulderMid = new THREE.Vector3().lerpVectors(pLeftShoulder, pRightShoulder, 0.5);
            const earMid = new THREE.Vector3().lerpVectors(pLeftEar, pRightEar, 0.5);

            const yAxis = new THREE.Vector3().subVectors(earMid, shoulderMid);
            const xAxis = new THREE.Vector3().subVectors(pRightEar, pLeftEar);
            
            // Geometric correction to remove forward tilt
            const projection = xAxis.clone().multiplyScalar(yAxis.dot(xAxis) / xAxis.lengthSq());
            const correctedY = yAxis.clone().sub(projection).normalize();

            const zAxis = new THREE.Vector3().crossVectors(xAxis, correctedY).normalize();
            const finalX = new THREE.Vector3().crossVectors(correctedY, zAxis).normalize();

            const rotationMatrix = new THREE.Matrix4().makeBasis(finalX, correctedY, zAxis);
            const headQuaternion = new THREE.Quaternion().setFromRotationMatrix(rotationMatrix);
            character.head.quaternion.slerp(headQuaternion, lerpFactor);
            // --- End Head Logic ---

            character.leftArm.quaternion.slerp(getQuaternion(worldLandmarks[11], worldLandmarks[13]), lerpFactor);
            character.rightArm.quaternion.slerp(getQuaternion(worldLandmarks[12], worldLandmarks[14]), lerpFactor);
            character.leftLeg.quaternion.slerp(getQuaternion(worldLandmarks[23], worldLandmarks[25]), lerpFactor);
            character.rightLeg.quaternion.slerp(getQuaternion(worldLandmarks[24], worldLandmarks[26]), lerpFactor);
        }
        
        // --- RENDER LOOP & DRAWING ---
        let lastTime = -1;
        async function predict() {
            const w = video.videoWidth;
            const h = video.videoHeight;
            if(w > 0 && (canvas2D.width !== w || canvas2D.height !== h)) {
                canvas2D.width = w;
                canvas2D.height = h;
            }

            if (video.currentTime !== lastTime) {
                lastTime = video.currentTime;
                const results = poseLandmarker.detectForVideo(video, performance.now());
                
                ctx2D.clearRect(0, 0, w, h);
                ctx2D.drawImage(video, 0, 0, w, h);
                
                if (results.landmarks && results.landmarks[0]) {
                    if(showSkeleton) drawPoseSkeleton(results.landmarks[0]);
                    updatePose(results.landmarks[0]);
                }
            }

            if(renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            requestAnimationFrame(predict);
        }

        function drawPoseSkeleton(landmarks) {
            ctx2D.lineWidth = 3;
            ctx2D.strokeStyle = 'rgba(0, 255, 255, 0.7)';
            
            // MediaPipe's standard connections
            const connections = PoseLandmarker.POSE_CONNECTIONS;
            for (const connection of connections) {
                const start = landmarks[connection.start];
                const end = landmarks[connection.end];
                ctx2D.beginPath();
                ctx2D.moveTo(start.x * canvas2D.width, start.y * canvas2D.height);
                ctx2D.lineTo(end.x * canvas2D.width, end.y * canvas2D.height);
                ctx2D.stroke();
            }

            ctx2D.fillStyle = 'rgba(255, 0, 0, 0.8)';
            for (const landmark of landmarks) {
                ctx2D.beginPath();
                ctx2D.arc(landmark.x * canvas2D.width, landmark.y * canvas2D.height, 4, 0, 2 * Math.PI);
                ctx2D.fill();
            }
        }

        // --- UI & EVENTS ---
        function main() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'steve.webp',
                (texture) => {
                    setupThreeJS();
                    character = createCharacter(texture);
                    scene.add(character.group);
                    initialize();
                },
                undefined,
                (err) => {
                    console.error('Failed to load default skin.', err);
                    alert('Could not load steve.webp. Please ensure the file is in the same directory.');
                }
            );
        }
        main();
        
        document.getElementById('toggle-skel').addEventListener('click', (e) => {
            showSkeleton = !showSkeleton;
            e.target.innerText = showSkeleton ? "Hide Skeleton" : "Show Skeleton";
        });

        function handleResize() {
            viewWidth = window.innerWidth;
            viewHeight = window.innerHeight;
            if(camera && renderer) {
                camera.aspect = viewWidth / viewHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(viewWidth, viewHeight);

                // Recalculate visible plane size at Z=0
                const fovInRadians = camera.fov * (Math.PI / 180);
                visibleHeight = 2 * Math.tan(fovInRadians / 2) * camera.position.z;
                visibleWidth = visibleHeight * camera.aspect;
            }
        }
        window.addEventListener('resize', handleResize);

    </script>
</body>
</html>
